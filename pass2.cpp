#include <bits/stdc++.h>
using namespace std;

struct Symbol {
    string name;
    int addr;
};

struct Literal {
    string value;
    int addr;
};

class Pass2 {
public:
    vector<Symbol> symtab;
    vector<Literal> littab;

    Pass2(vector<Symbol> s, vector<Literal> l) {
        symtab = s;
        littab = l;
    }

    string extractNum(const string &s) {
        // Extract number inside parentheses e.g. (IS,04) → 04
        size_t c = s.find(',');
        size_t p = s.find(')');
        if (c != string::npos && p != string::npos && c+1 < p)
            return s.substr(c+1, p-c-1);
        return "";
    }

    void processIC(vector<string>& icLines) {
        cout << "\n--- PASS 2: MACHINE CODE ---\n";
        for (auto line : icLines) {
            stringstream ss(line);
            string loc, part;
            ss >> loc; // location counter

            if (loc.find("(AD") != string::npos) {
                // Handle directive-only line (no loc)
                loc = "";
            }

            if (!loc.empty() && isdigit(loc[0])) cout << loc << " ";
            else cout << "    ";

            vector<string> parts;
            while (ss >> part) parts.push_back(part);

            if (parts.empty()) { cout << "----\n"; continue; }

            if (parts[0].find("(IS") != string::npos) {
                string opcode = extractNum(parts[0]); // IS code
                cout << opcode << " ";

                string reg = "0", addr = "000";
                if (parts.size() >= 2 && parts[1].find("(RG") != string::npos) {
                    reg = extractNum(parts[1]);
                }
                if (parts.size() == 3) {
                    if (parts[2].find("(S") != string::npos) {
                        int idx = stoi(extractNum(parts[2])) - 1;
                        addr = to_string(symtab[idx].addr);
                    } else if (parts[2].find("(L") != string::npos) {
                        int idx = stoi(extractNum(parts[2])) - 1;
                        addr = to_string(littab[idx].addr);
                    }
                }
                cout << reg << " " << addr << endl;
            }
            else if (parts[0].find("(DL,01)") != string::npos) {
                // DC constant
                string constant = extractNum(parts[1]);
                cout << "00 0 " << constant << endl;
            }
            else if (parts[0].find("(DL,02)") != string::npos) {
                // DS – reserve memory, no actual machine code
                cout << "----" << endl;
            }
            else if (parts[0].find("(AD") != string::npos) {
                // Assembler directives (no machine code)
                cout << "----" << endl;
            }
        }
    }
};

int main() {
    // Example IC generated by Pass-1
    vector<string> intermediateCode = {
        "    (AD,01) (C,100)",
        "100 (IS,04) (RG,01) (L,1)",
        "101 (IS,01) (RG,02) (L,2)",
        "102 (IS,05) (RG,01) (S,1)",
        "103 (DL,02) (C,1)",
        "    (AD,02)"
    };

    // Example symbol and literal tables from Pass-1
    vector<Symbol> symtab = { {"ALPHA",103} };
    vector<Literal> littab = { {"=5",100}, {"=1",101} };

    Pass2 p2(symtab, littab);
    p2.processIC(intermediateCode);

    return 0;
}

/*

input:(intermediate code generation:)

    (AD,01) (C,100)
100 (IS,04) (RG,01) (L,1)
101 (IS,01) (RG,02) (L,2)
102 (IS,05) (RG,01) (S,1)
103 (DL,02) (C,1)
    (AD,02)


output:

--- PASS 2: MACHINE CODE ---

format:
<LC>  <OPCODE>  <REG>  <ADDRESS>

----                          ; START
100 04 01 100
101 01 02 101
102 05 01 103
103 ----                      ; DS
----                          ; END


*/